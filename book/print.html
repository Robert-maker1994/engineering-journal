<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Creating a book to help myself and others understand the basics in computer sciences, software engineering and coding katas.</p>
<p>How to break down this book, Computer Science book is about all things computer science, my vision for this project is to add things as I develop as a software engineer. To keep an online dairy of what I am learning and what I am learning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="software-engineering"><a class="header" href="#software-engineering">Software Engineering</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-hash-tables"><a class="header" href="#what-are-hash-tables">What are Hash Tables?</a></h1>
<p>Is a collection of key-value pairs known as an entries. HashTable&lt;int, string&gt;. It is designed to provide a 0(1) average-time complexity for basic operations like insertion, deletion and look up. They can also be called dictionaries in some languages.</p>
<h2 id="pros-and-cons-of-hash-tables"><a class="header" href="#pros-and-cons-of-hash-tables">Pros and Cons of Hash Tables</a></h2>
<p>Pros:</p>
<ul>
<li>Fast Operations: Average-case time complexity for insertion, deletion, and lookup is O(1).</li>
<li>Flexible Keys: Can store and retrieve values using complex keys like strings.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Collisions: Dealing with collisions can complicate implementation.</li>
<li>Space Usage: May require more memory than other data structures.</li>
<li>Worst-case Performance: Degrades to O(n) when the hash function is poorly designed or the table is too full.</li>
</ul>
<h2 id="how-a-hash-table-works"><a class="header" href="#how-a-hash-table-works">How a Hash Table Works</a></h2>
<p>Insert:</p>
<ul>
<li>Compute the hash of the key.</li>
<li>Place the key-value pair at the appropriate index (bucket).</li>
<li>If there's a collision, handle it using chaining or open addressing.
Search:</li>
<li>Compute the hash of the key.</li>
<li>Check the corresponding bucket for the key and return the associated value.
Delete:</li>
<li>Compute the hash of the key.</li>
<li>Remove the key-value pair from the appropriate bucket.</li>
</ul>
<h2 id="a-basic-hash-table-in-rust"><a class="header" href="#a-basic-hash-table-in-rust">A basic Hash table in rust.</a></h2>
<p>Documentation for a hash map in rust. <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">HashMap</a></p>
<pre><code>    //initialize with a capacity of 10
    let mut hash = HashMap::with_capacity(10);
    
    // Add you're entries. 
    hash.insert(100, "Spongebob");
    hash.insert(123, "Patrick");
    hash.insert(321, "Sandy");
    hash.insert(555, "Squidward");
    hash.insert(777, "Gary");
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-queue"><a class="header" href="#what-is-a-queue">What is a Queue?</a></h1>
<p>A <em>queue</em> is a linear data structure, it follows the <strong>First In, First Out</strong> (FIFO) principle.This means the first item added to the queue is the first one to be removed, much like a line of people waiting for a service.</p>
<h2 id="what-is-a-linear-data-structure"><a class="header" href="#what-is-a-linear-data-structure">What is a linear data structure?</a></h2>
<p>Linear means a straight line or one dimension.</p>
<p>A <em>linear data structure</em> is a type of data structure where elements are arranged sequentially, one after another, in a linear order. Each element is connected to it's previous and next element. (except the first and last elements).</p>
<p>Characteristics of a linear data structure?</p>
<ul>
<li>Sequential Arrangement</li>
<li>Single Level</li>
<li>Traversal</li>
<li>Contiguity or Linkage</li>
</ul>
<h2 id="key-characteristics-of-queue"><a class="header" href="#key-characteristics-of-queue">Key characteristics of queue?</a></h2>
<ul>
<li>FIFO Order: The order of insertion is the order of removal.</li>
<li>Two Ends:
<ul>
<li>Front: Where elements are dequeued (removed).</li>
<li>Rear: Where elements are enqueued (added).</li>
</ul>
</li>
<li>Dynamic Size: Can grow or shrink as elements are added or removed (depending on implementation).</li>
</ul>
<h2 id="types-of-queues"><a class="header" href="#types-of-queues">Types of Queues?</a></h2>
<ul>
<li>Simple Queue: Follows the basic FIFO principle.</li>
<li>Circular Queue: The rear wraps around to the front when the end of the queue is reached, optimizing space.</li>
<li>Priority Queue: Each element is associated with a priority, and elements are dequeued based on their priority, not their order.</li>
<li>Deque (Double-Ended Queue): Allows insertion and deletion from both ends.</li>
</ul>
<h2 id="where-would-you-use-a-queue"><a class="header" href="#where-would-you-use-a-queue">Where would you use a Queue?</a></h2>
<ol>
<li>Scheduling:
<ul>
<li>CPU task scheduling.</li>
<li>Printer task scheduling.</li>
</ul>
</li>
<li>Data Streaming:
<ul>
<li>Handling asynchronous data.</li>
</ul>
</li>
<li>Breadth-First Search (BFS):
<ul>
<li>A graph traversal algorithm uses a queue.</li>
</ul>
</li>
<li>Caching:
<ul>
<li>Maintaining a fixed-size cache using FIFO policy.</li>
</ul>
</li>
<li>Order Processing:
<ul>
<li>Managing requests or events in the order they arrive.</li>
</ul>
</li>
</ol>
<h2 id="implementing"><a class="header" href="#implementing">Implementing</a></h2>
<p>Implementing a queue in javascript would have to implement the queue using an array. For example in other languages are already built into the lang. <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">VecDeque</a></p>
<pre><code>class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(item) {
    this.items.push(item); // Add to the rear
  }

  dequeue() {
    if (!this.isEmpty()) {
      return this.items.shift(); // Remove from the front
    }
    return "Queue is empty!";
  }

  peek() {
    return this.isEmpty() ? "Queue is empty!" : this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-stack"><a class="header" href="#what-is-a-stack">What is a Stack?</a></h1>
<p>A stack is a fundamental data structure in computer science that operates on a <strong>Last In, First Out</strong> (LIFO) principle. This means that the last element added to the stack will be the first one to be removed. Think of it like a stack of plates: you can only take the top plate off the stack, and you can only add a new plate on top.</p>
<h2 id="key-operations"><a class="header" href="#key-operations">Key Operations</a></h2>
<ul>
<li>Push: Add an element to the top of the stack.</li>
<li>Pop: Remove the top element from the stack.</li>
<li>Peek/Top: View the top element without removing it.</li>
<li>IsEmpty: Check if the stack is empty.</li>
</ul>
<pre><code>struct Stack&lt;T&gt; {
    items: Vec&lt;T&gt;,
}

impl&lt;T&gt; Stack&lt;T&gt; {
    fn new() -&gt; Self {
        Stack { items: Vec::new() }
    }

    fn push(&amp;mut self, item: T) {
        self.items.push(item);
    }

    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.items.pop() // Removes and returns the last item
    }

    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.items.last() // Returns a reference to the last item
    }

    fn is_empty(&amp;self) -&gt; bool {
        self.items.is_empty()
    }

    fn size(&amp;self) -&gt; usize {
        self.items.len()
    }
}
´´´</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees-in-data-structures"><a class="header" href="#trees-in-data-structures">Trees in Data Structures</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>A tree is a widely used abstract data type that simulates a hierarchical tree structure with a set of connected nodes. Each node contains a value or data and may have a reference to other nodes, forming a parent-child relationship.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li><strong>Root</strong>: The top node of a tree.</li>
<li><strong>Leaf</strong>: A node with no children.</li>
<li><strong>Parent</strong>: A node that has one or more children.</li>
<li><strong>Child</strong>: A node that has a parent.</li>
<li><strong>Subtree</strong>: A tree consisting of a node and its descendants.</li>
<li><strong>Depth</strong>: The length of the path from the root to a node.</li>
<li><strong>Height</strong>: The length of the path from a node to the deepest leaf.</li>
<li><strong>Edge</strong>: The connection between two nodes.</li>
</ul>
<h2 id="key-characteristics"><a class="header" href="#key-characteristics">Key characteristics</a></h2>
<ul>
<li>Hierarchical structure</li>
<li>Non-linear: Unlike linear data structures like arrays or linked lists, trees allow for non-sequential access to data.</li>
<li>Nodes can have multiple children: This property enables trees to represent complex relationships between data.</li>
</ul>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<ul>
<li>File systems: Trees are used to organize files and directories.</li>
<li>Database indexing: Trees are employed to efficiently search and retrieve data.</li>
<li>Compilers: Trees are used to represent the syntax and semantics of programming languages.</li>
<li>Graph algorithms: Trees are a fundamental data structure for graph traversal and manipulation.</li>
</ul>
<h2 id="types-of-trees"><a class="header" href="#types-of-trees">Types of Trees</a></h2>
<ul>
<li><strong>Binary Tree</strong>: Each node has at most two children.</li>
<li><strong>Binary Search Tree (BST)</strong>: A binary tree where the left child contains values less than the parent node, and the right child contains values greater than the parent node.</li>
<li><strong>Balanced Tree</strong>: A tree where the height of the left and right subtrees of any node differ by at most one.</li>
<li><strong>AVL Tree</strong>: A self-balancing binary search tree.</li>
<li><strong>Red-Black Tree</strong>: A binary search tree with an extra bit of storage per node to ensure the tree remains balanced.</li>
</ul>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<ul>
<li><strong>Insertion</strong>: Adding a node to the tree.</li>
<li><strong>Deletion</strong>: Removing a node from the tree.</li>
<li><strong>Traversal</strong>: Visiting all the nodes in a specific order (e.g., in-order, pre-order, post-order).</li>
</ul>
<h2 id="applications-1"><a class="header" href="#applications-1">Applications</a></h2>
<ul>
<li><strong>Hierarchical Data Representation</strong>: File systems, organizational structures.</li>
<li><strong>Searching and Sorting</strong>: Binary search trees, AVL trees.</li>
<li><strong>Network Routing</strong>: Spanning trees in network design.</li>
</ul>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TreeNode&lt;T&gt; {
    value: T,
    left: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
    right: Option&lt;Box&lt;TreeNode&lt;T&gt;&gt;&gt;,
}

impl&lt;T&gt; TreeNode&lt;T&gt; {
    fn new(value: T) -&gt; Self {
        TreeNode {
            value,
            left: None,
            right: None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Trees are fundamental data structures that provide efficient ways to store and manage hierarchical data. Understanding their properties and operations is crucial for solving complex problems in computer science.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th>Word</th><th>Description</th></tr></thead><tbody>
<tr><td>Dynamic</td><td>To be able to change easily. For example, to change or adapt at runtime.</td></tr>
<tr><td>&lt;&lt; or &gt;&gt;</td><td>Where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</td></tr>
<tr><td>Linear</td><td>Linear means a straight line or one dimension.</td></tr>
<tr><td>Contiguous</td><td>Next to or touching another, usually similar, thing.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-heap-and-the-stack"><a class="header" href="#understanding-the-heap-and-the-stack">Understanding the heap and the Stack</a></h1>
<p>The heap and the stack are two fundamental memory allocation mechanisms used in programming languages. Understanding their differences and how they work is crucial for efficient memory management and program performance.</p>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>The stack operates in a first-in, first-out (FIFO) flow.  It is used to store local variables, functions parameters and return addresses. The stack is and efficient but limited size.</p>
<h2 id="characteristics-of-the-stack"><a class="header" href="#characteristics-of-the-stack">Characteristics of the Stack</a></h2>
<ul>
<li>Fast Allocation and Deallocation: Memory allocation and deallocation on the stack are very fast because they follow a simple LIFO order.</li>
<li>Limited Size: The stack has a limited size, which can lead to stack overflow if too much data is stored.</li>
<li>Automatic Management: In many programming languages, the stack is automatically managed, ensuring that variables are deallocated when they go out of scope.</li>
</ul>
<pre><code>void function() {
    int x = 42; // x is stored on the stack
    float y = 3.14; // y is also stored on the stack
    // When the function exits, x and y are automatically deallocated
}
</code></pre>
<h2 id="the-heap"><a class="header" href="#the-heap">The Heap</a></h2>
<p>The heap is a region of memory used for dynamic memory allocation. It is used for storing data that needs to live beyond the scope of a single function or for data that is too large to fit on the stack.</p>
<h2 id="characteristics-of-the-heap"><a class="header" href="#characteristics-of-the-heap">Characteristics of the Heap</a></h2>
<ul>
<li>Dynamic Allocation: Memory on the heap is allocated dynamically at runtime using functions like malloc in C, new in C++, or new in Java.</li>
<li>Slower Allocation and Deallocation: Allocating and deallocating memory on the heap is slower than on the stack because it involves more complex bookkeeping.</li>
<li>Manual Management: In many programming languages, heap memory must be manually managed, meaning the programmer is responsible for deallocating memory when it is no longer needed.</li>
</ul>
<pre><code>void function() {
    int* x = (int*)malloc(sizeof(int)); // x is a pointer to a value stored on the heap
    *x = 42;
    float* y = (float*)malloc(sizeof(float)); // y is a pointer to a value stored on the heap
    *y = 3.14;
    // When the function exits, x and y must be manually deallocated
    free(x);
    free(y);
}
</code></pre>
<h2 id="when-to-use-the-heap-and-the-stack"><a class="header" href="#when-to-use-the-heap-and-the-stack">When to Use the Heap and the Stack</a></h2>
<h3 id="use-the-stack"><a class="header" href="#use-the-stack">Use the Stack:</a></h3>
<ul>
<li>For small, short-lived variables.</li>
<li>For function parameters and local variables.</li>
<li>When you need fast allocation and deallocation.</li>
</ul>
<h3 id="use-the-heap"><a class="header" href="#use-the-heap">Use the Heap:</a></h3>
<ul>
<li>For large data structures that need to live beyond the scope of a single function.</li>
<li>For data that needs to be shared or modified across different parts of the program.</li>
<li>When you need dynamic memory allocation.</li>
</ul>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The stack is fast and automatically managed, making it ideal for small, short-lived variables. The heap is used for dynamic memory allocation, allowing for larger and more complex data structures. By leveraging the strengths of both the heap and the stack you shall be able to manage and improve performance and reliability of your programs</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<ul>
<li>https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-engineering"><a class="header" href="#data-engineering">Data Engineering</a></h1>
<p>Data engineering is the practice of designing and building systems for collecting, storing, and analyzing data at scale. It involves the development of architectures, tools, and processes that enable the efficient and reliable handling of large volumes of data. Key responsibilities of data engineers include:</p>
<ul>
<li><strong>Data Collection</strong>: Gathering data from various sources, including databases, APIs, and streaming services.</li>
<li><strong>Data Storage</strong>: Designing and implementing data storage solutions such as data warehouses, data lakes, and databases.</li>
<li><strong>Data Processing</strong>: Transforming raw data into a usable format through ETL (Extract, Transform, Load) processes.</li>
<li><strong>Data Integration</strong>: Combining data from different sources to provide a unified view.</li>
<li><strong>Data Quality</strong>: Ensuring the accuracy, consistency, and reliability of data.</li>
<li><strong>Data Security</strong>: Implementing measures to protect data from unauthorized access and breaches.</li>
</ul>
<p>Data engineering is a critical component of the data lifecycle, enabling organizations to leverage data for analytics, machine learning, and decision-making.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="katas-collection"><a class="header" href="#katas-collection">Katas collection.</a></h2>
<p>This is a collection of katas I have created in the past to improve my skills as a software engineer. A lot of the katas here are organized by Topics. To learn more venture into the topic.</p>
<p>To see the documentation run.
<code>cargo doc --open</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
